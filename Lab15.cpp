

//1. Описать функцию PowerA3(A, B), 
//   вычисляющую третью степень числа A и возвращающую ее в переменной B 
//   (A — входной, B — выходной параметр; оба параметра являются вещественными). 
//   С помощью этой функции найти третьи степени пяти данных чисел.

#include <iostream>

// Функция для вычисления 3 степени числа a
void PowerA3(float A, float* B) 
{
    *B = A * A * A;
}

int main()
{ 
    // Создаем цикл для рассчета третьей степени для 5 чисел
    for (int i = 1; i <= 5; ++i) {
        float A;

        printf("A:");
        scanf_s("%f", &A);

        float B;

        PowerA3(A, &B);

        // Вывод результата
        printf_s("B: %f\n", B); 
    }

    return 0;
}

// 2. Описать функцию Sign(X) целого типа, 
//    возвращающую для вещественного числа X следующие значения:
//    −1, если X < 0; 0, если X = 0; 1, если X > 0. 
//    С помощью этой функции найти значение выражения Sign(A) + Sign(B) для данных вещественных чисел A и B.
#include <iostream>

int sign(float x) 
{
    if (x < 0) 
        return -1;  

    if (x == 0) 
        return 0;     

    if (x > 0) 
        return 1; 
}

int main(void)
{
    float a, b; 

    printf("A:");
    scanf_s("%f", &a);
    printf("B:");
    scanf_s("%f", &b);

    // Вывод результата
    printf("Sign(A)+Sign(B):%i\n", sign(a) + sign(b)); 

    return 0;
}


// 3. Описать функцию RingS(R1, R2) вещественного типа, 
//    находящую площадь кольца, заключенного между двумя окружностями 
//    с общим центром и радиусами R1 и R2 (R1 и R2 — вещественные, R1 > R2). 
//    С ее помощью найти площади трех колец, для которых даны внешние и внутренние радиусы.
#include <iostream>

 // Функция для вычисления площади кольца
float rings(float r1, float r2) {
    return 3.14 * (r1 * r1 - r2 * r2);
}

int main(void)
{
    int i;

    // Цикл для расчета площади 3 различных колец
    for (i = 1; i <= 3; ++i) {  
        float r1, r2; 

        printf("R1:"); 
        scanf("%f", &r1);
        printf("R2:");
        scanf("%f", &r2);
        
        // Вывод результата
        printf("S:%f\n", rings(r1, r2)); 
    }

    return 0;
}
// 4. Описать функцию Quarter(x, y) целого типа, 
//    определяющую номер координатной четверти, в которой находится точка с 
//    ненулевыми вещественными координатами (x, y). 
//    С помощью этой функции найти номера координатных четвертей для трех точек с данными ненулевыми координатами
#include <iostream>

// Функция для определения номера координатной четверти
int quarter(float x, float y) { 
    if ((x > 0) && (y > 0))
        return 1;

    if ((x < 0) && (y > 0))  
        return 2; 

    if ((x < 0) && (y < 0))  
        return 3;     

    if ((x > 0) && (y < 0))  
        return 4; 
}

int main(void)
{
    int i;

    // Цикл для определения номера координатной четверти три раза
    for (i = 1; i <= 3; ++i) { 
        float x, y;

        printf("X:");
        scanf("%f", &x);
        printf("Y:");
        scanf("%f", &y);

        // Вывод результата
        printf("Quarter:%i\n", quarter(x, y)); 
    }

    return 0;
}
// 5. Описать функцию Fact2(N) вещественного типа, вычисляющую двойной факториал: 
//    N!! = 1·3·5·. . .·N, если N — нечетное; 
//    N!! = 2·4·6·. . .·N, если N — четное (N > 0 — параметр целого типа; 
//    вещественное возвращаемое значение используется для того, 
//    чтобы избежать целочисленного переполнения при больших значениях N).
#include <iostream>

// Функция для вычисления двойного факториала
float Fact2(unsigned int n) { 
    int fact_double = 1;

    // Для четных
    if (n % 2 == 0) {
        for (int i = 2; i <= n; i += 2)
            fact_double *= i;
    }
    // Для нечетных
    else {
        for (int i = 1; i <= n; i += 2)
            fact_double *= i;
    }
    
    return fact_double;
}

int main() {
    int n;

    std::cin >> n;
    std::cout << Fact2(n); 

    return 0;
}
